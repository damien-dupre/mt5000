---
title: "MT5000 - Data Analytics & Visualization"
subtitle: "Lecture 9: Transformations in R with the {tidyverse}"
author: "Damien Dupré"
date: "Dublin City University"
output:
  xaringan::moon_reader:
    css: ["default", "metropolis", "metropolis-fonts", "css/custom_design.css"]
    lib_dir: libs
    nature:
      beforeInit: "libs/cols_macro.js"
      highlightStyle: zenburn
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include = FALSE}
# general options --------------------------------------------------------------
options(
  scipen = 999,
  htmltools.preserve.raw = FALSE
)
set.seed(42)
# chunk options ----------------------------------------------------------------
knitr::opts_chunk$set(
  cache.extra = knitr::rand_seed, 
  message = FALSE, 
  warning = FALSE, 
  error = FALSE, 
  echo = FALSE,
  cache = FALSE,
  comment = "", 
  fig.align = "center", 
  fig.retina = 3
  )
# libraries --------------------------------------------------------------------
library(tidyverse)
library(knitr)
library(kableExtra)
library(fontawesome)
library(tweetrmd)
library(countdown)
library(gapminder)
# functions --------------------------------------------------------------------
# https://bookdown.org/yihui/rmarkdown-cookbook/font-color.html#using-an-r-function-to-write-raw-html-or-latex-code

colorize <- function(x, color) {
  sprintf("<span style='color: %s;'>%s</span>", color, x)
  }
```

# R so far

We have already seen how to:

- Use RStudio Cloud
- Install, load and use packages
- Run R code in R Script or R Markdown files
- Use keyboard shortcuts: `Ctrl` & `Enter` (Win) / `Command` & `Enter` (Mac)
- Create object with the assignment arrow `<-` sign
- Upload and read data in RStudio Cloud

Now let's enter the {tidyverse}

```{r out.width='30%'}
include_graphics("https://tidyverse.tidyverse.org/articles/tidyverse-logo.png")
```

---

# Rstudio Cloud

In your webrowser (Chrome, Firefox, ...):

1. Open these same slides on a tab to copy-paste the examples
  - From Loop: Lectures > Lecture 9
  - Or from the URL: https://damien-dupre.github.io/mt5000/lectures/lecture_9

2. In another tab, go to: https://rstudio.cloud/
  - Sign in or Sign up (if not already done)
  - In your workspace, Click "Untitled Project" or "New Project" (if not already done) 

```{r out.width='100%'}
knitr::include_graphics("https://miro.medium.com/max/1400/1*JBHNRwGr3ZiyBzYWpvH6zg.png")
```

---

# Entering the {tidyverse}

The {tidyverse} package is primarily made up of a set of super useful R packages ({ggplot2}, {dplyr}, {purrr}, {tidyr}, {readr}, {tibble}).

It is also a new way of thinking about implementing “tidy” data analysis. 

If you combine tidy thinking with the {tidyverse} packages, you will inevitably become a master of tidy analysis. 

The tidyverse has a very detailed website for more information: https://www.tidyverse.org/.

```{r eval=FALSE, echo=TRUE}
install.packages("tidyverse")
library(tidyverse)
```

---

# {dplyr}'s main functions

There are five **{dplyr}** functions that you will use to do the vast majority of data manipulations:

- `filter()`: Subset observations (pick observations by their values)

- `select()`: Subset variables (pick variables by their names)

- `mutate()`: Make new variables (create new variables with functions of existing variables)

- `summarise()`: Summarise data (collapse many values down to a single summary)

These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group.

These five functions provide the verbs for a language of data manipulation.

---

# {dplyr}'s main functions

All verbs work similarly:

- `r colorize("The first argument is a dataframe object name", "red")` 
- `r colorize("The subsequent arguments describe how the dataframe is transformed", "green")` 
- `r colorize("The result is a new dataframe", "blue")`

Here is a generic example:

.center[**`r colorize("dataframe_transformed", "blue")` `<-` function_name(`r colorize("dataframe_name", "red")`, `r colorize("transformation", "green")`)**
]

---

# The gapminder dataset

The dataset used today is stored in the {gapminder} package into an object called `gapminder`. 

Each row in this table corresponds to a country at a specific year. For each row, we have 6 columns:

- **country**: Name of country.
- **year**: Year of the observation (between 1952 and 2007).
- **pop**: Number of people living in the country.
- **continent**: Which of the five continents the country is part of. 
- **lifeExp**: Life expectancy in years.
- **gdpPercap**: Gross domestic product (in US dollars).

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1. Install the package {gapminder} which contains the data gapminder
2. Load the package {gapminder} to access the data
3. Use the function `str()` on the gapminder data 

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 1. The filter() function

---

# The filter() function

You will want to isolate bits of your data; maybe you want to only look at a single country or a few years. R calls this subsetting and `filter()` allows you to subset observations based on their values.

`filter()`'s transformation is a conditional statement, only observations TRUE to the condition are kept.

For example

```{r eval=FALSE, echo=TRUE}
filter(gapminder, country == "Ireland")
```

Importantly, Column/Variable names are not between quotation marks in the Tidyverse whereas the value to filter is
- A Column/Variable is an object containing multiple values inside the data frame object.
- The string "Ireland" does not exist in our environment and will not be saved. It is here just as a value, which explains the quotation marks.

---

# Comparisons

To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: `>`, `>=`, `<`, `<=`, `!=` (not equal), and `==` (exactly equal).

When you’re starting out with R, the easiest mistake to make is to use `=` instead of `==` when testing for equality. When this happens you’ll get an informative error:

```{r eval=FALSE, echo=TRUE}
filter(gapminder, country = "Ireland")
```

```out
Error: Problem with `filter()` input `..1`.
x Input `..1` is named.
ℹ This usually means that you've used `=` instead of `==`.
ℹ Did you mean `country == "Ireland"`?
```

---

# Multiple filters

Whereas the `filter()` can include as many conditions as possible, it is also possible to store the result of the `filter()` function in a new object and then to apply a new filter on this new object.

```{r eval=FALSE, echo=TRUE}
gapminder_ireland <- filter(gapminder, country == "Ireland")

gapminder_ireland_2007 <- filter(gapminder_ireland, year == 2007)
```

A choice is offered to you, you can either overwrite the original object by using the same object name or to use a different object name.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1. Be sure that the packages {tidyverse} and {gapminder} are loaded
2. Create a new object that only contains data for France
3. Create a new object using the previous object that only contains data for France in 1982

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 2. The select() function

---

# The select() function

It’s not uncommon to get datasets with hundreds or even thousands of variables. In this case, the first challenge is often narrowing in on the variables you’re actually interested in. 

`select()` allows you to rapidly zoom in on a useful subset using operations based on the names of the variables. 

Again the first argument is the name of the data frame object to process and the following arguments are the name of the columns to keep.

```{r eval=FALSE, echo=TRUE}
select(gapminder, country, year, pop)
```

---

# Keep and remove variables

The `select()` function can not only be used to keep specific variables but it can also be used to remove them from the data frame object. 

To do so, just add the `-` sign in front of the variable name to be removed. For example:

```{r eval=FALSE, echo=TRUE}
gapminder_keep <- select(gapminder, country, year, pop)

gapminder_remove <- select(gapminder, -continent, -lifeExp, -gdpPercap)
```

In the previous example the objects `gapminder_keep` and `gapminder_remove` should have the same number of variable and therefore be equal.

---

# Select and rename variables

While you are keeping only specify variables with `select()`, these variables can also be renamed on the same time. 

The new name has to be first, followed by the `=` sign, and the old name.

Example:

```{r eval=FALSE, echo=TRUE}
select(gapminder, country, population = pop, measure_year = year)
```

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, select the columns `lifeExp` and `gdpPercap` and rename them as life_expectancy and gdp_per_capita:

```{r eval=FALSE, echo=TRUE}
select(_ _ _, _ _ _ = _ _ _, _ _ _ = _ _ _)
```

2/ From the data frame object `gapminder`, remove the columns `pop` and `year` and assign the result in a new object. The display the value of this object:

```{r eval=FALSE, echo=TRUE}
new_data <- select(_ _ _, -_ _ _, -_ _ _)

new_data
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 3. The mutate() function

---

# The mutate() function

Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. That’s the job of `mutate()`. 

Once again the first argument is the name of the data frame object to modify, then the second argument is the name of the column to create followed by the `=` sign and the condition creating the new values.

For example we can create a new column called `gdp_total` which contains the values resulting from the multiplication between `pop` and `gdpPercap`:

```{r eval=FALSE, echo=TRUE}
mutate(gapminder, gdp_total = pop * gdpPercap)
```

`mutate()` can also create multiple columns in the same statement, they just have to be separated by a comma `,`.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, create a new column called `country_upper` with the function `toupper()` using the column `country`:

```{r eval=FALSE, echo=TRUE}
mutate(_ _ _, _ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, filter the countries in Europe and their values for 2007. Assign the result to an new object called `europe_2007`. 
Then create a new column called `europe_prop` corresponding to the value of the column `pop` divided by the total population in Europe in 2007.

```{r eval=FALSE, echo=TRUE}
europe_2007 <- filter(_ _ _, _ _ _ == _ _ _ & _ _ _ == _ _ _)

mutate(_ _ _, _ _ _ = _ _ _/_ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 4. The summarise() function

---

# The summarise() function

The last key verb is `summarise()`. It collapses a data frame to a single row:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, mean(pop))
summarise(gapminder, sd(pop))
```

The result of `summarise()` is a dataframe, the default header of the summary is the calculation but a new header can be defined by using the `=` sign when summarising the data:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, m_pop = mean(pop))
summarise(gapminder, sd_pop = sd(pop))
```

Finally, more than one summary can be done inside a `summarise()`:

```{r eval=FALSE, echo=TRUE}
summarise(gapminder, m_pop = mean(pop), sd_pop = sd(pop))
```

---

# The summarise() function

`summarise()` is not terribly useful unless we pair it with `group_by()`. This changes the unit of analysis from the complete dataset to individual groups. Then, when you use the dplyr verbs on a grouped data frame they’ll be automatically applied “by group”. 

For example, if we applied exactly the same code to a data frame grouped by year, we get the average world population per year:

```{r echo=TRUE}
gapminder_by_year <- group_by(gapminder, year)

summarise(gapminder_by_year, mean_pop = mean(pop))
```

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, summarise the population average with the `mean()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them):

```{r eval=FALSE, echo=TRUE}
gapminder_group <- group_by(_ _ _, _ _ _, _ _ _)

summarise(_ _ _, _ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, summarise the population standard deviation with the `sd()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them):

```{r eval=FALSE, echo=TRUE}
gapminder_group <- group_by(_ _ _, _ _ _, _ _ _)

summarise(_ _ _, _ _ _ = _ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 5. The pipe operator %>%

---

# The pipe operator %>%

Imagine that we want to summarise the population average and standard deviation only of Europe. Using what you know about {dplyr}, you might write code like this:

```{r eval=FALSE, echo=TRUE}
gapminder_europe <- filter(gapminder, continent == "Europe")

gapminder_summary_europe <- summarise(gapminder_europe, 
  m_pop = mean(pop),
  sd_pop = sd(pop)
)
```

This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don’t care about it. Naming things is hard, so this slows down our analysis.

---

# The pipe operator %>% 

There’s another way to tackle the same problem with the pipe, `%>%`:

```{r eval=FALSE, echo=TRUE}
gapminder_summary_europe <- gapminder %>% 
  filter(continent == "Europe") %>% 
  summarise(m_pop = mean(pop), sd_pop = sd(pop))
```

---

# The pipe operator %>%

You can read it as a series of imperative statements: group, then summarise, then filter in the first example and: filter, then summarise in the second example. As suggested by this reading, a good way to pronounce `%>%` when reading code is **“then”**.

```{r eval=FALSE, echo=TRUE}
gapminder_summary_europe <- gapminder %>% 
  filter(continent == "Europe") %>% 
  summarise(m_pop = mean(pop), sd_pop = sd(pop))
```

Becomes

> Create the object "gapminder_summary_europe" from the object "gapminder", then

> Filter all the values exactly equals to "Europe" in the continent variable, then

> Summarise the average population as "m_pop" and the standard deviation as "sd_pop".

---

# The pipe operator %>%

Behind the scenes, `x %>% f()` turns into `f(x)`, and `x %>% f() %>% g()` turns into `g(f(x))` and so on.

The following sequence can be read as:
1. Take `x` then
2. Use it as the input to the function `f()` then
3. Use `f(x)` as the input to the function `g()` then
4. Use `g(f(x))` as the input to the function `h()`

```{r eval=FALSE, echo=TRUE}
x %>% 
  f() %>% 
  g() %>% 
  h()
```

Working with the pipe is one of the key criteria for belonging to the tidyverse. The only exception is {ggplot2}.

---
class: title-slide, middle

## Live Demo

---
class: title-slide, middle

## Exercise

1/ From the data frame object `gapminder`, summarise the population average with the `mean()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them) and by using the pipe operator:

```{r eval=FALSE, echo=TRUE}
_ _ _ %>% 
  group_by(_ _ _, _ _ _) %>% 
  summarise(_ _ _ = _ _ _(_ _ _))
```

2/ From the data frame object `gapminder`, summarise the population standard deviation with the `sd()` function by `year` and by `continent` by adding the second grouping variable after the first one (use a coma to separate them) and by using the pipe operator:

```{r eval=FALSE, echo=TRUE}
_ _ _ %>% 
  group_by(_ _ _, _ _ _) %>% 
  summarise(_ _ _ = _ _ _(_ _ _))
```

```{r}
countdown(minutes = 5, warn_when = 60)
```

---

class: inverse, mline, center, middle

# 6. The left/right/full/inner_join() functions

---

# Join 2 Tables

.pull-left[
The principle is simple, two different tables are sharing a key variable. By joining these two table by this key variable, it is possible to merge them into one table and to keep all variables.

However, there are different cases, imagine that your X table (on the left) has more observations on the key variable than the Y table (on the right)

]

.pull-right[
```{r out.width='100%'}
include_graphics("https://raw.githubusercontent.com/gadenbuie/tidyexplain/master/images/static/png/original-dfs.png")
```
]

You might want to keep:
- Only the observations included in the left table
- Only the observations included in the right table
- Only the observations included in both tables
- All observations

For more visualisation see [Tidy Animated Verbs](https://www.garrickadenbuie.com/project/tidyexplain/)

---

# Join 2 Tables

```{r out.width='50%'}
include_graphics("https://rafalab.github.io/dsbook/wrangling/img/joins.png")
```

---

class: inverse, mline, center, middle

# 7. Pivot Longer or Pivot Wider

---

# Pivot Longer or Pivot Wider

Sometimes we need to reformat or reshape our data in order to analyse it or visualize it in a specific way. Two tidyverse functions, `pivot_longer()` and `pivot_wider()`, help us to do this.

![](https://thinkr.fr/wp-content/uploads/pivot.png?raw=true)

---

# Pivot Wider

In the `gapminder` dataset, we currently have a column/variable year and the population for the same country is repeated according multiple rows. This is a "Tidy" format, but sometimes it is handy to have a column per year for the same country: this is a "wide" format. Wide means that the value of a specific variable is spread on multiple columns.

To obtain this wider version of the dataset, it is possible to use the `pivot_wider()` function from the {tidyr} package.

![](https://d33wubrfki0l68.cloudfront.net/8350f0dda414629b9d6c354f87acf5c5f722be43/bcb84/images/tidy-8.png?raw=true)

---

# Pivot Wider

`pivot_wider()` has 3 main arguments:
1. The dataset to pivot (but it can be omitted if it follows a pipe operator)
2. `names_from` which corresponds to the variable converted to column names
3. `values_from` which corresponds to the values inside the new variables

For example, the following code will spread the years as new columns displaying the population per country:

```{r eval=FALSE, echo=TRUE}
gapminder_wider <- gapminder %>% 
  select(country, year, pop) %>% 
  pivot_wider(names_from = year, values_from = pop)
```

---

# Pivot Longer

Usually R is working with long tables, not wide. For this reason it is very useful to reorganise a dataset with the `pivot_longer()` function.

![](https://i0.wp.com/cmdlinetips.com/wp-content/uploads/2020/02/pivot_longer_wide_to_long_tidy.jpg?raw=true)

---

# Pivot Longer

`pivot_longer()` has 4 main arguments:
1. The dataset to pivot (but it can be omitted if it follows a pipe operator)
2. `names_to` which corresponds to the column names aggregated in a new variable
3. `values_to` which corresponds to the values aggregated in a new variable
4. The last argument `cols` corresponds to the column names to be aggregated. Observe how we set this to `-country` indicating that we don’t want to “tidy” the country but all the other variables

```{r eval=FALSE, echo=TRUE}
gapminder_longer <- gapminder_wider %>% 
  pivot_longer(names_to = "year", values_to = "pop", cols = -country)
```

For `pivot_longer()` the new variables are in quotation marks because they are not present in the existing `gapminder_wider` table whereas `country` is and has no quotation mark.

---

class: inverse, mline, center, middle

# 8. Save Your Data

---

# Save Your Data

Usually, only R Script file (.R) or R Markdown file (.Rmd) have to be saved as they allow the full replicability of transformations and result.

However if you want to use the data that have been transformed, joined or pivoted, a function has to be used according the type of export.

The simpliest export is a .csv file with the function `write.csv()`. It as two main arguments:
- `x` which is the name of the object to save
- `file` which is the name of the output file

Note: don't forget the file extension in the argument `file`

Example:

```{r eval=FALSE, echo=TRUE}
write.csv(gapminder_wider, "data_gapminder_transformed.csv")
```

---
class: inverse, mline, left, middle

<img class="circle" src="https://github.com/damien-dupre.png" width="250px"/>

# Thanks for your attention and don't hesitate to ask any questions!

[`r fa(name = "twitter")` @damien_dupre](http://twitter.com/damien_dupre)  
[`r fa(name = "github")` @damien-dupre](http://github.com/damien-dupre)  
[`r fa(name = "link")` damien-datasci-blog.netlify.app](https://damien-datasci-blog.netlify.app)  
[`r fa(name = "paper-plane")` damien.dupre@dcu.ie](mailto:damien.dupre@dcu.ie)
